#!/usr/bin/env python
#
# This file is part of ddr-cmdln/ddr
#
#  

# IDEAS: 
# https://xrunhprof.wordpress.com/2012/06/14/changing-git-committers-and-authors-with-python/
# https://jonmccune.wordpress.com/2012/06/17/code-release-history-and-aesthetics-with-git-filter-branch-and-friends/
# http://www.snip2code.com/Snippet/10557/To-remove-files-from-git-history-after-t/
# http://www.bioperl.org/wiki/Using_Git/Advanced#Prepare_list_of_files_to_be_removed


description = """Filters a collection for publication."""
epilog = """More things to say about filter-branch."""

import argparse
import ConfigParser
import json
import logging
import os
import sys

import git

from DDR import CONFIG_FILE

class NoConfigError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

if not os.path.exists(CONFIG_FILE):
    raise NoConfigError('No config file!')
config = ConfigParser.ConfigParser()
config.read(CONFIG_FILE)

DEBUG = config.get('local','debug')

LOGGING_FORMAT = '%(asctime)s %(levelname)s %(message)s'
LOGGING_DATEFMT = '%Y-%m-%d %H:%M:%S'
LOGGING_FILE = config.get('local','log_file')
if config.get('local','log_level') == 'debug':
    LOGGING_LEVEL = logging.DEBUG
else:
    LOGGING_LEVEL = logging.ERROR
#logging.basicConfig(format=LOGGING_FORMAT, datefmt=LOGGING_DATEFMT, level=LOGGING_LEVEL, filename=LOGGING_FILE)
logging.basicConfig(format=LOGGING_FORMAT, datefmt=LOGGING_DATEFMT, level=logging.DEBUG, filename=LOGGING_FILE)


def annex_get( path ):
    """Get annex files from origin.
    """
    repo = git.Repo(path)
    repo.git.annex('get .')


# ----------------------------------------------------------------------
# Clone repository, prepending "filtering" to repo directory name
# (e.g. "ddr-densho-123" -> "filtering_ddr-densho-123")

def mk_dest_path( source, destdir, status ):
    """
    @param source: Absolute path to source collection repository.
    @param destdir: Absolute path to destination dir.
    @param status: Current status in the process
    @returns: Absolute path to destination repository dir.
    """
    srccid = os.path.basename(source)
    destcid = '%s_%s' % (status, srccid)
    dest_path = os.path.join(destdir, destcid)
    return dest_path

def clone( source, dest_path ):
    """Clones source repository into destdir.
    
    @param source: Absolute path to source collection repository.
    @param dest_path
    @returns: A GitPython Repository
    """
    print('Cloning %s to %s' % (source, dest_path))
    repo = git.Repo.clone_from(source, dest_path)
    # git annex init if not already existing
    if not os.path.exists(os.path.join(dest_path, '.git', 'annex')):
        repo.git.annex('init')
    repo.git.checkout('master')
    print('ok')
    return repo


# ----------------------------------------------------------------------
# Remove all git and git-annex remotes.
# Confirm all git and git-annex remotes removed.

def rm_remotes( repo ):
    """Remove all git and git-annex remotes.
    
    @param repo: A GitPython Repository
    """
    print('Removing remotes... NOT IMPLEMENTED YET!')

def confirm_remotes_removed( repo ):
    """Confirm all git and git-annex remotes removed.
    
    @param repo: A GitPython Repository
    @returns: True/False
    """
    print('Confirming remotes removal... NOT IMPLEMENTED YET!')


# ----------------------------------------------------------------------
# Walk directory to find all .json files
# For each .json check public/private status.
# If private, add file(s) to exclusion list.
# Exclusion list will be fed to git filter-branch command.

def json_files(dirname):
    """Lists absolute paths to .json files in dirname; skips .git directory.
    
    @param path: Absolute path to collection repository directory
    @returns: list of absolute paths
    """
    paths = []
    exclude_dirs = ['tmp', '.git']
    for root, dirs, files in os.walk(dirname):
        # don't walk .git/ or tmp dirs
        for d in exclude_dirs:
            if d in dirs:
                dirs.remove(d)
        for f in files:
            if f.endswith('.json'):
                paths.append(os.path.join(root, f))
    return paths

def is_collection_json( path ):
    if 'collection.json' in path:
        return True
    return False
def is_entity_json( path ):
    if 'entity.json' in path:
        return True
    return False
def is_file_json( path ):
    for x in ['master', 'mezzanine']:
        if x in os.path.basename(path):
            return True
    return False

def is_public( json_path ):
    """Indicates whether the Collection or Entity is public.
    
    Specifically, indicates whether metadata file contains public=1 value.
    DDR metadata .json files consist of a list of dicts.
    'Public' is indicated by a '1' str.
    
    @param path: Absolute path to *.json file.
    @returns: True or False
    """
    data = None
    with open(json_path, 'r') as f:
        data = json.loads(f.read())
    if data:
        for field in data:
            if ((u'public' in field.keys()) or ('public' in field.keys())):
                if int(field['public']):
                    return True
    return False

def is_public_file( json_path ):
    """Indicates whether the File is public.
    
    See is_public for details.
    
    @param path: Absolute path to *.json file.
    @returns: True or False
    """
    data = None
    with open(json_path, 'r') as f:
        data = json.loads(f.read())
    if data:
        for field in data:
            if ((u'public' in field.keys()) or ('public' in field.keys())):
                if int(field['public']):
                    return True
    return False

def nonpublic_json_files( dest_path ):
    paths = []
    for path in json_files(dest_path):
        if   is_collection_json(path):
            if not is_public(path):
                paths.append(path)
        elif is_entity_json(path):
            if not is_public(path):
                paths.append(path)
        elif is_file_json(path):
            if not is_public_file(path):
                paths.append(path)
        else:
            print('UNKNOWN FILE TYPE')
            sys.exit(1)
    return paths

def nonpublic_collection( path ):
    """Excludes the whole collection directory.
    """
    assert False
def nonpublic_entity( path ):
    """Excludes the whole entity directory.
    """
    return ['%s/' % os.path.dirname(path)]
def nonpublic_file( path ):
    """Excludes the file's original file, access file, and metadata.
    ddr-testing-141-1-master-96c048001e-a.jpg
    ddr-testing-141-1-master-96c048001e.json
    ddr-testing-141-1-master-96c048001e.pdf
    """
    return ['%s*' % os.path.splitext(path)[0]]

def all_nonpublic_files( nonpublic_json_paths ):
    """
    """
    paths = []
    for p in nonpublic_json_paths:
        if   is_collection_json(p): paths = paths + nonpublic_collection(p)
        elif is_entity_json(p):     paths = paths + nonpublic_entity(p)
        elif is_file_json(p):       paths = paths + nonpublic_file(p)
    return paths

def make_exclusion_list( dest_path ):
    """Find jsons; For each .json note public/private status; if private add to exclusion list.
    
    @param dest_path
    @returns exclusion_list
    """
    nonpublic_json = nonpublic_json_files(dest_path)
    exclusion_list = all_nonpublic_files(nonpublic_json)
    print('These files will be excluded:')
    for p in exclusion_list:
        print('    %s' % p)
    return exclusion_list


# ----------------------------------------------------------------------
# Run git-filter-branch on the exclusion list

def filter_branch():
    """Run the git-filter-branch command.
    """
    assert False


# ----------------------------------------------------------------------
# Filter script excludes dirs/files based on exclusion list.

def per_commit_function( path, exclusion_list_path ):
    """Filter script excludes dirs/files based on exclusion list.
    
    This function is run on every commit.
    It loads the exclusion list file and excludes all the files in it.
    
    @param path: Absolute path to collection repository directory
    @param exclusion_list: relative path to exclusion list file
    """
    pass


# ----------------------------------------------------------------------
# Rename repo directory ("filtering_ddr-densho-123" -> "public_ddr-densho-123").
# Confirm all git and git-annex remotes removed.

def wrap_up():
    """Rename repo directory ("filtering_ddr-densho-123" -> "public_ddr-densho-123").
    """
    pass



def main():

    parser = argparse.ArgumentParser(description=description, epilog=epilog)
    parser.add_argument('-n', '--noclone', help='Do not clone.')
    parser.add_argument('-d', '--dryrun', help="Don't actually do anything, just say what you WOULD do.")
    parser.add_argument('--inner', help="Run inner-loop commands.")
    parser.add_argument('source', help='Absolute path to source repository.')
    parser.add_argument('destdir', help='Absolute path to directory in which new repository will be placed.')
    args = parser.parse_args()
    
    if args.destdir == args.source:
        print('ddrfilter: error: Source and destdir are the same!')
        sys.exit(1)
    
    dest_path = mk_dest_path(args.source, args.destdir, 'filtering')
    
    if os.path.exists(dest_path):
        print('ddrfilter: error: Destination path already exists! (%s)' % dest_path)
        sys.exit(1)
    
    repo = clone(args.source, dest_path)
    rm_remotes(repo)
    remotes_removed = confirm_remotes_removed(repo)
    exclusion_list = make_exclusion_list(dest_path)
    # run git-filter-branch
    # clean up

if __name__ == '__main__':
    main()
