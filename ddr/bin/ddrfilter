#!/usr/bin/env python
#
# This file is part of ddr-cmdln/ddr
#
#  

"""
IDEAS:
https://xrunhprof.wordpress.com/2012/06/14/changing-git-committers-and-authors-with-python/
https://jonmccune.wordpress.com/2012/06/17/code-release-history-and-aesthetics-with-git-filter-branch-and-friends/
http://www.snip2code.com/Snippet/10557/To-remove-files-from-git-history-after-t/
http://www.bioperl.org/wiki/Using_Git/Advanced#Prepare_list_of_files_to_be_removed
"""

description = """Filters a collection for publication."""
epilog = """More things to say about filter-branch."""

import argparse
import ConfigParser
from datetime import datetime
import json
import logging
import os
import sys

import envoy
import git

from DDR import CONFIG_FILE

class NoConfigError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

if not os.path.exists(CONFIG_FILE):
    raise NoConfigError('No config file!')
config = ConfigParser.ConfigParser()
config.read(CONFIG_FILE)

DEBUG = config.get('local','debug')

#LOGGING_FORMAT = '%(asctime)s %(levelname)s %(message)s'
#LOGGING_DATEFMT = '%Y-%m-%d %H:%M:%S'
#LOGGING_FILE = config.get('local','log_file')
#if config.get('local','log_level') == 'debug':
#    LOGGING_LEVEL = logging.DEBUG
#else:
#    LOGGING_LEVEL = logging.ERROR
##logging.basicConfig(format=LOGGING_FORMAT, datefmt=LOGGING_DATEFMT, level=LOGGING_LEVEL, filename=LOGGING_FILE)
#logging.basicConfig(format=LOGGING_FORMAT, datefmt=LOGGING_DATEFMT, level=logging.DEBUG, filename=LOGGING_FILE)


def dtfmt(dt): return dt.strftime('%Y-%m-%dT%H:%M:%S.%f')
def now(): return datetime.now()

def annex_get( path ):
    """Get annex files from origin.
    """
    repo = git.Repo(path)
    repo.git.annex('get .')


# ----------------------------------------------------------------------
# Clone repository, prepending "filtering" to repo directory name
# (e.g. "ddr-densho-123" -> "filtering_ddr-densho-123")

def mk_dest_path( source, destdir, status ):
    """
    @param source: Absolute path to source collection repository.
    @param destdir: Absolute path to destination dir.
    @param status: Current status in the process
    @returns: Absolute path to destination repository dir.
    """
    srccid = os.path.basename(source)
    destcid = '%s_%s' % (status, srccid)
    dest_path = os.path.join(destdir, destcid)
    return dest_path

def clone( source, dest_path ):
    """Clones source repository into destdir.
    
    @param source: Absolute path to source collection repository.
    @param dest_path
    @returns: A GitPython Repository
    """
    repo = git.Repo.clone_from(source, dest_path)
    # git annex init if not already existing
    if not os.path.exists(os.path.join(dest_path, '.git', 'annex')):
        repo.git.annex('init')
    repo.git.checkout('master')
    return repo

def annex_list( repo_path, level ):
    """List annex files of the specified level
    
    @param repo_path
    @param repo: A GitPython Repository
    @param level: 
    """
    if   level == 'access':    match = '*-a.jpg'
    elif level == 'mezzanine': match = '*-mezzanine-*'
    elif level == 'master':    match = '*-master-*'
    os.chdir(repo_path)
    cmd = 'git annex whereis %s' % match
    r = envoy.run(cmd, timeout=30)
    files = []
    for line in r.std_out.split('\n'):
        if 'whereis' in line:
            files.append(line.split(' ')[1])
    return files
    
def annex_get( repo, filename ):
    """git-annex-get specified filename
    
    @param repo: A GitPython Repository
    @param filename: Relative path
    """
    repo.git.annex('get', filename)

# ----------------------------------------------------------------------
# Remove all git and git-annex remotes.

def rm_remotes( repo ):
    """Remove all git and git-annex remotes.
    
    @param repo: A GitPython Repository
    @return: 0 if ok, list of remotes if not
    """
    for remote in repo.remotes:
        repo.delete_remote(remote)
    if repo.remotes:
        return repo.remotes
    return 0


# ----------------------------------------------------------------------
# Walk directory to find all .json files
# For each .json check public/private status.
# If private, add file(s) to exclusion list.
# Exclusion list will be fed to git filter-branch command.

def list_json_files(dirname):
    """Lists absolute paths to .json files in dirname; skips .git directory.
    
    @param path: Absolute path to collection repository directory
    @returns: list of absolute paths
    """
    paths = []
    exclude_dirs = ['tmp', '.git']
    for root, dirs, files in os.walk(dirname):
        # don't walk .git/ or tmp dirs
        for d in exclude_dirs:
            if d in dirs:
                dirs.remove(d)
        for f in files:
            if f.endswith('.json'):
                paths.append(os.path.join(root, f))
    return paths

def is_collection_json( path ):
    if 'collection.json' in path:
        return True
    return False
def is_entity_json( path ):
    if 'entity.json' in path:
        return True
    return False
def is_file_json( path ):
    for x in ['master', 'mezzanine']:
        if x in os.path.basename(path):
            return True
    return False

def is_public( json_path ):
    """Indicates whether the Collection or Entity is public.
    
    Specifically, indicates whether metadata file contains public=1 value.
    DDR metadata .json files consist of a list of dicts.
    'Public' is indicated by a '1' str.
    
    @param path: Absolute path to *.json file.
    @returns: True or False
    """
    data = None
    with open(json_path, 'r') as f:
        data = json.loads(f.read())
    if data:
        for field in data:
            if ((u'public' in field.keys()) or ('public' in field.keys())):
                if int(field['public']):
                    return True
    return False

def is_public_file( json_path ):
    """Indicates whether the File is public.
    
    See is_public for details.
    
    @param path: Absolute path to *.json file.
    @returns: True or False
    """
    data = None
    with open(json_path, 'r') as f:
        data = json.loads(f.read())
    if data:
        for field in data:
            if ((u'public' in field.keys()) or ('public' in field.keys())):
                if int(field['public']):
                    return True
    return False

def nonpublic_json_files( json_files ):
    paths = []
    for path in json_files:
        if   is_collection_json(path):
            if not is_public(path):
                paths.append(path)
        elif is_entity_json(path):
            if not is_public(path):
                paths.append(path)
        elif is_file_json(path):
            if not is_public_file(path):
                paths.append(path)
        else:
            print('UNKNOWN FILE TYPE')
            assert False
    return paths

def nonpublic_collection( path ):
    """Excludes the whole collection directory.
    """
    assert False
def nonpublic_entity( path ):
    """Excludes the whole entity directory.
    
    >>> nonpublic_entity('.../ddr-testing-123/files/ddr-testing-123-4/entity.json')
    '.../ddr-testing-123/files/ddr-testing-123-4/'
    
    @param path: Absolute path to entity.json
    @returns: directory containing entity
    """
    return '%s/' % os.path.dirname(path)
def nonpublic_file( path ):
    """Excludes the file's original file, access file, and metadata.
    
    >>> nonpublic_file('.../ddr-testing-123/files/ddr-testing-123-3/files/ddr-testing-123-3-master-1a2b3c4d5e.json')
    '.../ddr-testing-123/files/ddr-testing-123-3/files/ddr-testing-123-3-master-1a2b3c4d5e*'
    
    @param path: Absolute path to file json.
    @returns: path that matches file JSON, original file, access copies.
    """
    return '%s*' % os.path.splitext(path)[0]

def all_nonpublic_files( nonpublic_json_paths ):
    """
    """
    paths = []
    for p in nonpublic_json_paths:
        if   is_collection_json(p): paths.append(nonpublic_collection(p))
        elif is_entity_json(p):     paths.append(nonpublic_entity(p))
        elif is_file_json(p):       paths.append(nonpublic_file(p))
    return paths

def make_exclusion_list( dest_path ):
    """Makes list of paths to be excluded from the repository.
    
    @param dest_path
    @returns: List of relative paths to private files/dirs.
    """
    files_json = list_json_files(dest_path)
    nonpublic_json = nonpublic_json_files(files_json)
    exclusion_list = all_nonpublic_files(nonpublic_json)
    exclusion_list.sort()
    # make paths relative
    for n,path in enumerate(exclusion_list):
        exclusion_list[n] = path.replace(dest_path, '')[1:]
    return exclusion_list

def write_exclusion_list( dest_path, exclusion_list, filename ):
    """Writes exclusion list to the specified directory.
    
    @param dest_path
    @param exclusion_list
    @param filename
    @return: filename if ok, 1 if not
    """
    fname = os.path.join(dest_path, filename)
    #cmd = 'git rm -rf %s\n'
    cmd = 'git rm -qrf --cached --ignore-unmatch %s ;\\\n'
    #cmd = 'git rm -rf --cached --ignore-unmatch %s ;\\\n'
    actions = [cmd % path for path in exclusion_list]
    with open(fname, 'w') as f:
        f.writelines(actions)
    if os.path.exists(fname):
        return fname
    return 1


# ----------------------------------------------------------------------
# Run git-filter-branch on the exclusion list

def filter_branch( repo_path, exclusion_list_path ):
    """Run the git-filter-branch command.
    
    Reference:
    https://jonmccune.wordpress.com/2012/06/17/code-release-history-and-aesthetics-with-git-filter-branch-and-friends/
    
    @param exclusion_list_path
    """
    repo_parent_dir = os.path.dirname(repo_path)
    new_repo_path = repo_path.replace('filtering', 'published')
    
    #cmd = "$ git filter-branch -d /dev/shm/git --tree-filter 'sh %s' --prune-empty HEAD" % exclusion_list_path
    
    #cmd = 'pushd .\n' \
    #      'cd %s\n' \
    #      'git filter-branch -d /dev/shm/git --index-filter "sh %s" --prune-empty HEAD\n' \
    #      'mv %s %s\n' \
    #      'popd' % (repo_path, exclusion_list_path, repo_path, new_repo_path)
    
    ## this sequence garbage-collects in place.  DOESN'T SEEM TO WORK
    #cmd = 'pushd . ; ' \
    #      'cd %s ; ' \
    #      'git filter-branch -d /dev/shm/git --index-filter "sh %s" --prune-empty HEAD && ' \
    #      'git for-each-ref --format="%%(refname)" refs/original/ | xargs -n 1 git update-ref -d && ' \
    #      'git reflog expire --verbose --expire=0 --all && ' \
    #      'git gc --prune=0 && ' \
    #      'mv %s %s ; ' \
    #      'popd' % (repo_path, exclusion_list_path, repo_path, new_repo_path)
    
    # this sequence clones a new repo after running filter-branch as a way to garbage-collect
    cmd = 'pushd . ; ' \
          'cd %s ; ' \
          'git filter-branch -d /dev/shm/git --index-filter "sh %s" --prune-empty HEAD && ' \
          'cd %s ; ' \
          'git clone --no-hardlinks %s %s && ' \
          'rm -Rf %s && ' \
          'popd' % (repo_path, exclusion_list_path, repo_parent_dir, repo_path, new_repo_path, repo_path)
    
    # must not be run as ddr user, requires sudo to delete filtering_* annex files.
    # this sequence clones a new repo after running filter-branch as a way to garbage-collect
    cmd = 'pushd . ; ' \
          'cd %s ; ' \
          'git filter-branch -d /dev/shm/git --index-filter "sh %s" --prune-empty HEAD && ' \
          'cd %s ; ' \
          'git clone --no-hardlinks %s %s && ' \
          'sudo rm -Rf %s && ' \
          'popd' % (repo_path, exclusion_list_path, repo_parent_dir, repo_path, new_repo_path, repo_path)

    return cmd


# ----------------------------------------------------------------------
# Filter script excludes dirs/files based on exclusion list.

def per_commit_function( path, exclusion_list_path ):
    """Filter script excludes dirs/files based on exclusion list.
    
    This function is run on every commit.
    It loads the exclusion list file and excludes all the files in it.
    
    @param path: Absolute path to collection repository directory
    @param exclusion_list: relative path to exclusion list file
    """
    pass


# ----------------------------------------------------------------------
# Rename repo directory ("filtering_ddr-densho-123" -> "public_ddr-densho-123").
# Confirm all git and git-annex remotes removed.

def wrap_up():
    """Rename repo directory ("filtering_ddr-densho-123" -> "public_ddr-densho-123").
    """
    pass



def main():

    parser = argparse.ArgumentParser(description=description, epilog=epilog)
    #parser.add_argument('-n', '--noclone', help='Do not clone.')
    #parser.add_argument('--inner', help="Run inner-loop commands.")
    parser.add_argument('-l', '--list', action='store_const', const=1, help='Generate exclusion list from source repository.')
    parser.add_argument('-M', '--master', action='store_const', const=1, help='git-annex copy master files.')
    parser.add_argument('-m', '--mezzanine', action='store_const', const=1, help='git-annex copy mezzanine files.')
    parser.add_argument('-a', '--access', action='store_const', const=1, help='git-annex copy access files.')
    parser.add_argument('-d', '--destdir', help='Absolute path to directory in which new repository will be placed.')
    parser.add_argument('-s', '--source', required=True, help='Absolute path to source repository.')
    args = parser.parse_args()
    
    # check args
    if (not args.destdir) and (not args.list):
        print('ddrfilter: error: -d/--destdir is required except when using -l/--list.')
        sys.exit(1)
    if args.destdir == args.source:
        print('ddrfilter: error: Source and destdir are the same!')
        sys.exit(1)
    
    if args.list:
        # Just generate exclusion list
        print('%s Generating exclusion list from %s' % (dtfmt(now()), args.source))
        exclusion_list = make_exclusion_list(args.source)
        sys.exit(1)
    
    else:
        # check args
        dest_path = mk_dest_path(args.source, args.destdir, 'filtering')
        if os.path.exists(dest_path):
            print('ddrfilter: error: Destination path already exists! (%s)' % dest_path)
            sys.exit(1)
        
        started = now()
        print('%s - Starting filter' % dtfmt(started))
        
        print('%s - Cloning %s to %s' % (dtfmt(now()), args.source, dest_path))
        repo = clone(args.source, dest_path)
        if not repo:
            print('ddrfilter: error: Could not clone repository!')
            sys.exit(1)
        
        file_levels = []
        if args.access: file_levels.append('access')
        if args.mezzanine: file_levels.append('mezzanine')
        if args.master: file_levels.append('master')
        
        print('%s - Getting files...' % dtfmt(now()))
        for level in file_levels:
            print('%s - %s' % (dtfmt(now()), level))
            files = annex_list(dest_path, level)
            fstarted = datetime.now()
            for n,fname in enumerate(files):
                annex_get(repo, fname)
                print('%s - %s/%s %s' % (dtfmt(now()), n, len(files), fname))
            ffinished = datetime.now()
            felapsed = ffinished - fstarted
            print('%s - elapsed %s' % (dtfmt(now()), felapsed))
        
        print('%s - Removing remotes...' % dtfmt(now()))
        rm_remotes_status = rm_remotes(repo)
        if rm_remotes_status:
            print('ddrfilter: error: Failed to remove one or more remotes: %s' % rm_remotes_status)
            sys.exit(1)
        
        print('%s - Generating exclusion list...' % dtfmt(now()))
        exclusion_list = make_exclusion_list(dest_path)
        for p in exclusion_list:
            print(p)

        print('%s - Writing exclusion list...' % dtfmt(now()))
        exlist = write_exclusion_list(dest_path, exclusion_list, 'exclusions')
        if os.path.exists(exlist):
            print(exlist)
        else:
            print('ddrfilter: error: Failed to write exclusion list.')
            sys.exit(1)
        
        # run git-filter-branch
        cmd = filter_branch(dest_path, exlist)
        print('Run this command:\n\n%s\n' % cmd)
        # clean up
        
        finished = now()
        elapsed = finished - started
        print('%s done' % dtfmt(finished))
        print('%s elapsed' % elapsed)
        print('')

if __name__ == '__main__':
    main()
